"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/opentelemetry-instrumentation-fetch-node";
exports.ids = ["vendor-chunks/opentelemetry-instrumentation-fetch-node"];
exports.modules = {

/***/ "(ssr)/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchInstrumentation = void 0;\n/*\n * Portions from https://github.com/elastic/apm-agent-nodejs\n * Copyright Elasticsearch B.V. and other contributors where applicable.\n * Licensed under the BSD 2-Clause License; you may not use this file except in\n * compliance with the BSD 2-Clause License.\n *\n */\nconst node_diagnostics_channel_1 = __importDefault(__webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\"));\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(ssr)/./node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nfunction getMessage(error) {\n    if (error instanceof AggregateError) {\n        return error.errors.map((e) => e.message).join(', ');\n    }\n    return error.message;\n}\n// Get the content-length from undici response headers.\n// `headers` is an Array of buffers: [k, v, k, v, ...].\n// If the header is not present, or has an invalid value, this returns null.\nfunction contentLengthFromResponseHeaders(headers) {\n    const name = 'content-length';\n    for (let i = 0; i < headers.length; i += 2) {\n        const k = headers[i];\n        if (k.length === name.length && k.toString().toLowerCase() === name) {\n            const v = Number(headers[i + 1]);\n            if (!Number.isNaN(Number(v))) {\n                return v;\n            }\n            return undefined;\n        }\n    }\n    return undefined;\n}\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass FetchInstrumentation {\n    // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n    // unsubscribing.\n    channelSubs;\n    spanFromReq = new WeakMap();\n    tracer;\n    config;\n    meter;\n    instrumentationName = 'opentelemetry-instrumentation-node-18-fetch';\n    instrumentationVersion = '1.0.0';\n    instrumentationDescription = 'Instrumentation for Node 18 fetch via diagnostics_channel';\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        const channel = node_diagnostics_channel_1.default.channel(diagnosticChannel);\n        channel.subscribe(onMessage);\n        this.channelSubs.push({\n            name: diagnosticChannel,\n            channel,\n            onMessage,\n        });\n    }\n    constructor(config) {\n        // Force load fetch API (since it's lazy loaded in Node 18)\n        fetch('').catch(() => { });\n        this.channelSubs = [];\n        this.meter = api_1.metrics.getMeter(this.instrumentationName, this.instrumentationVersion);\n        this.tracer = api_1.trace.getTracer(this.instrumentationName, this.instrumentationVersion);\n        this.config = { ...config };\n    }\n    disable() {\n        this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));\n    }\n    enable() {\n        this.subscribeToChannel('undici:request:create', (args) => this.onRequest(args));\n        this.subscribeToChannel('undici:request:headers', (args) => this.onHeaders(args));\n        this.subscribeToChannel('undici:request:trailers', (args) => this.onDone(args));\n        this.subscribeToChannel('undici:request:error', (args) => this.onError(args));\n    }\n    setTracerProvider(tracerProvider) {\n        this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n    }\n    setMeterProvider(meterProvider) {\n        this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n    }\n    setConfig(config) {\n        this.config = { ...config };\n    }\n    getConfig() {\n        return this.config;\n    }\n    onRequest({ request }) {\n        // Don't instrument CONNECT - see comments at:\n        // https://github.com/elastic/apm-agent-nodejs/blob/c55b1d8c32b2574362fc24d81b8e173ce2f75257/lib/instrumentation/modules/undici.js#L24\n        if (request.method === 'CONNECT') {\n            return;\n        }\n        if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {\n            return;\n        }\n        const span = this.tracer.startSpan(`HTTP ${request.method}`, {\n            kind: api_1.SpanKind.CLIENT,\n            attributes: {\n                [semantic_conventions_1.SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),\n                [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: request.method,\n                [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: request.path,\n                'http.client': 'fetch',\n            },\n        });\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        if (this.config.onRequest) {\n            this.config.onRequest({ request, span, additionalHeaders: addedHeaders });\n        }\n        if (Array.isArray(request.headers)) {\n            request.headers.push(...Object.entries(addedHeaders).flat());\n        }\n        else {\n            request.headers += Object.entries(addedHeaders)\n                .map(([k, v]) => `${k}: ${v}\\r\\n`)\n                .join('');\n        }\n        this.spanFromReq.set(request, span);\n    }\n    onHeaders({ request, response }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            // We are currently *not* capturing response headers, even though the\n            // intake API does allow it, because none of the other `setHttpContext`\n            // uses currently do.\n            const cLen = contentLengthFromResponseHeaders(response.headers);\n            const attrs = {\n                [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode,\n            };\n            if (cLen) {\n                attrs[semantic_conventions_1.SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;\n            }\n            span.setAttributes(attrs);\n            span.setStatus({\n                code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.OK,\n                message: String(response.statusCode),\n            });\n        }\n    }\n    onDone({ request }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.end();\n            this.spanFromReq.delete(request);\n        }\n    }\n    onError({ request, error }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.recordException(error);\n            span.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: getMessage(error),\n            });\n            span.end();\n        }\n    }\n}\nexports.FetchInstrumentation = FetchInstrumentation;\nfunction getAbsoluteUrl(origin, path = '/') {\n    const url = `${origin}`;\n    if (origin.endsWith('/') && path.startsWith('/')) {\n        return `${url}${path.slice(1)}`;\n    }\n    if (!origin.endsWith('/') && !path.startsWith('/')) {\n        return `${url}/${path.slice(1)}`;\n    }\n    return `${url}${path}`;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb24tZmV0Y2gtbm9kZS9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1CQUFPLENBQUMsMERBQTBCO0FBQ3JGLCtCQUErQixtQkFBTyxDQUFDLHdIQUFxQztBQUM1RSxjQUFjLG1CQUFPLENBQUMsc0ZBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdEQUFnRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxJQUFJLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxrQkFBa0IsSUFBSSxFQUFFLGNBQWM7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixJQUFJLEdBQUcsY0FBYztBQUN2QztBQUNBLGNBQWMsSUFBSSxFQUFFLEtBQUs7QUFDekI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcmVwdWxzZS8uL25vZGVfbW9kdWxlcy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbi1mZXRjaC1ub2RlL2J1aWxkL2luZGV4LmpzP2FlZjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZldGNoSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuLypcbiAqIFBvcnRpb25zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvYXBtLWFnZW50LW5vZGVqc1xuICogQ29weXJpZ2h0IEVsYXN0aWNzZWFyY2ggQi5WLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHdoZXJlIGFwcGxpY2FibGUuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDItQ2xhdXNlIExpY2Vuc2U7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluXG4gKiBjb21wbGlhbmNlIHdpdGggdGhlIEJTRCAyLUNsYXVzZSBMaWNlbnNlLlxuICpcbiAqL1xuY29uc3Qgbm9kZV9kaWFnbm9zdGljc19jaGFubmVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6ZGlhZ25vc3RpY3NfY2hhbm5lbFwiKSk7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuZnVuY3Rpb24gZ2V0TWVzc2FnZShlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5lcnJvcnMubWFwKChlKSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xufVxuLy8gR2V0IHRoZSBjb250ZW50LWxlbmd0aCBmcm9tIHVuZGljaSByZXNwb25zZSBoZWFkZXJzLlxuLy8gYGhlYWRlcnNgIGlzIGFuIEFycmF5IG9mIGJ1ZmZlcnM6IFtrLCB2LCBrLCB2LCAuLi5dLlxuLy8gSWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCwgb3IgaGFzIGFuIGludmFsaWQgdmFsdWUsIHRoaXMgcmV0dXJucyBudWxsLlxuZnVuY3Rpb24gY29udGVudExlbmd0aEZyb21SZXNwb25zZUhlYWRlcnMoaGVhZGVycykge1xuICAgIGNvbnN0IG5hbWUgPSAnY29udGVudC1sZW5ndGgnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBrID0gaGVhZGVyc1tpXTtcbiAgICAgICAgaWYgKGsubGVuZ3RoID09PSBuYW1lLmxlbmd0aCAmJiBrLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IE51bWJlcihoZWFkZXJzW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIodikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBBIGNvbWJpbmF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL2FwbS1hZ2VudC1ub2RlanMgYW5kXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2FkZ2V0LWluYy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbnMvYmxvYi9tYWluL3BhY2thZ2VzL29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9zcmMvaW5kZXgudHNcbmNsYXNzIEZldGNoSW5zdHJ1bWVudGF0aW9uIHtcbiAgICAvLyBLZWVwIHJlZiB0byBhdm9pZCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQyMTcwIGJ1ZyBhbmQgZm9yXG4gICAgLy8gdW5zdWJzY3JpYmluZy5cbiAgICBjaGFubmVsU3VicztcbiAgICBzcGFuRnJvbVJlcSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdHJhY2VyO1xuICAgIGNvbmZpZztcbiAgICBtZXRlcjtcbiAgICBpbnN0cnVtZW50YXRpb25OYW1lID0gJ29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9uLW5vZGUtMTgtZmV0Y2gnO1xuICAgIGluc3RydW1lbnRhdGlvblZlcnNpb24gPSAnMS4wLjAnO1xuICAgIGluc3RydW1lbnRhdGlvbkRlc2NyaXB0aW9uID0gJ0luc3RydW1lbnRhdGlvbiBmb3IgTm9kZSAxOCBmZXRjaCB2aWEgZGlhZ25vc3RpY3NfY2hhbm5lbCc7XG4gICAgc3Vic2NyaWJlVG9DaGFubmVsKGRpYWdub3N0aWNDaGFubmVsLCBvbk1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5vZGVfZGlhZ25vc3RpY3NfY2hhbm5lbF8xLmRlZmF1bHQuY2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCk7XG4gICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKG9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbFN1YnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBkaWFnbm9zdGljQ2hhbm5lbCxcbiAgICAgICAgICAgIGNoYW5uZWwsXG4gICAgICAgICAgICBvbk1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLy8gRm9yY2UgbG9hZCBmZXRjaCBBUEkgKHNpbmNlIGl0J3MgbGF6eSBsb2FkZWQgaW4gTm9kZSAxOClcbiAgICAgICAgZmV0Y2goJycpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbFN1YnMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXRlciA9IGFwaV8xLm1ldHJpY3MuZ2V0TWV0ZXIodGhpcy5pbnN0cnVtZW50YXRpb25OYW1lLCB0aGlzLmluc3RydW1lbnRhdGlvblZlcnNpb24pO1xuICAgICAgICB0aGlzLnRyYWNlciA9IGFwaV8xLnRyYWNlLmdldFRyYWNlcih0aGlzLmluc3RydW1lbnRhdGlvbk5hbWUsIHRoaXMuaW5zdHJ1bWVudGF0aW9uVmVyc2lvbik7XG4gICAgICAgIHRoaXMuY29uZmlnID0geyAuLi5jb25maWcgfTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsU3Vicz8uZm9yRWFjaCgoc3ViKSA9PiBzdWIuY2hhbm5lbC51bnN1YnNjcmliZShzdWIub25NZXNzYWdlKSk7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmNyZWF0ZScsIChhcmdzKSA9PiB0aGlzLm9uUmVxdWVzdChhcmdzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpoZWFkZXJzJywgKGFyZ3MpID0+IHRoaXMub25IZWFkZXJzKGFyZ3MpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJywgKGFyZ3MpID0+IHRoaXMub25Eb25lKGFyZ3MpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJywgKGFyZ3MpID0+IHRoaXMub25FcnJvcihhcmdzKSk7XG4gICAgfVxuICAgIHNldFRyYWNlclByb3ZpZGVyKHRyYWNlclByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMudHJhY2VyID0gdHJhY2VyUHJvdmlkZXIuZ2V0VHJhY2VyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICB9XG4gICAgc2V0TWV0ZXJQcm92aWRlcihtZXRlclByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubWV0ZXIgPSBtZXRlclByb3ZpZGVyLmdldE1ldGVyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICB9XG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHsgLi4uY29uZmlnIH07XG4gICAgfVxuICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cbiAgICBvblJlcXVlc3QoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgLy8gRG9uJ3QgaW5zdHJ1bWVudCBDT05ORUNUIC0gc2VlIGNvbW1lbnRzIGF0OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxhc3RpYy9hcG0tYWdlbnQtbm9kZWpzL2Jsb2IvYzU1YjFkOGMzMmIyNTc0MzYyZmMyNGQ4MWI4ZTE3M2NlMmY3NTI1Ny9saWIvaW5zdHJ1bWVudGF0aW9uL21vZHVsZXMvdW5kaWNpLmpzI0wyNFxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pZ25vcmVSZXF1ZXN0SG9vayAmJiB0aGlzLmNvbmZpZy5pZ25vcmVSZXF1ZXN0SG9vayhyZXF1ZXN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4oYEhUVFAgJHtyZXF1ZXN0Lm1ldGhvZH1gLCB7XG4gICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfVVJMXTogZ2V0QWJzb2x1dGVVcmwocmVxdWVzdC5vcmlnaW4sIHJlcXVlc3QucGF0aCksXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfTUVUSE9EXTogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfVEFSR0VUXTogcmVxdWVzdC5wYXRoLFxuICAgICAgICAgICAgICAgICdodHRwLmNsaWVudCc6ICdmZXRjaCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdENvbnRleHQgPSBhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pO1xuICAgICAgICBjb25zdCBhZGRlZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KHJlcXVlc3RDb250ZXh0LCBhZGRlZEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcub25SZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5vblJlcXVlc3QoeyByZXF1ZXN0LCBzcGFuLCBhZGRpdGlvbmFsSGVhZGVyczogYWRkZWRIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVycykpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5wdXNoKC4uLk9iamVjdC5lbnRyaWVzKGFkZGVkSGVhZGVycykuZmxhdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBPYmplY3QuZW50cmllcyhhZGRlZEhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTogJHt2fVxcclxcbmApXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BhbkZyb21SZXEuc2V0KHJlcXVlc3QsIHNwYW4pO1xuICAgIH1cbiAgICBvbkhlYWRlcnMoeyByZXF1ZXN0LCByZXNwb25zZSB9KSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW5Gcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGN1cnJlbnRseSAqbm90KiBjYXB0dXJpbmcgcmVzcG9uc2UgaGVhZGVycywgZXZlbiB0aG91Z2ggdGhlXG4gICAgICAgICAgICAvLyBpbnRha2UgQVBJIGRvZXMgYWxsb3cgaXQsIGJlY2F1c2Ugbm9uZSBvZiB0aGUgb3RoZXIgYHNldEh0dHBDb250ZXh0YFxuICAgICAgICAgICAgLy8gdXNlcyBjdXJyZW50bHkgZG8uXG4gICAgICAgICAgICBjb25zdCBjTGVuID0gY29udGVudExlbmd0aEZyb21SZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9TVEFUVVNfQ09ERV06IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNMZW4pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIXSA9IGNMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwID8gYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IgOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5PSyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTdHJpbmcocmVzcG9uc2Uuc3RhdHVzQ29kZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRvbmUoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbkZyb21SZXEuZ2V0KHJlcXVlc3QpO1xuICAgICAgICBpZiAoc3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5zcGFuRnJvbVJlcS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcih7IHJlcXVlc3QsIGVycm9yIH0pIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbkZyb21SZXEuZ2V0KHJlcXVlc3QpO1xuICAgICAgICBpZiAoc3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnJvcik7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2V0TWVzc2FnZShlcnJvciksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZldGNoSW5zdHJ1bWVudGF0aW9uID0gRmV0Y2hJbnN0cnVtZW50YXRpb247XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVVybChvcmlnaW4sIHBhdGggPSAnLycpIHtcbiAgICBjb25zdCB1cmwgPSBgJHtvcmlnaW59YDtcbiAgICBpZiAob3JpZ2luLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3VybH0ke3BhdGguc2xpY2UoMSl9YDtcbiAgICB9XG4gICAgaWYgKCFvcmlnaW4uZW5kc1dpdGgoJy8nKSAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3VybH0vJHtwYXRoLnNsaWNlKDEpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt1cmx9JHtwYXRofWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js\n");

/***/ }),

/***/ "(instrument)/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchInstrumentation = void 0;\n/*\n * Portions from https://github.com/elastic/apm-agent-nodejs\n * Copyright Elasticsearch B.V. and other contributors where applicable.\n * Licensed under the BSD 2-Clause License; you may not use this file except in\n * compliance with the BSD 2-Clause License.\n *\n */\nconst node_diagnostics_channel_1 = __importDefault(__webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\"));\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(instrument)/./node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(instrument)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nfunction getMessage(error) {\n    if (error instanceof AggregateError) {\n        return error.errors.map((e) => e.message).join(', ');\n    }\n    return error.message;\n}\n// Get the content-length from undici response headers.\n// `headers` is an Array of buffers: [k, v, k, v, ...].\n// If the header is not present, or has an invalid value, this returns null.\nfunction contentLengthFromResponseHeaders(headers) {\n    const name = 'content-length';\n    for (let i = 0; i < headers.length; i += 2) {\n        const k = headers[i];\n        if (k.length === name.length && k.toString().toLowerCase() === name) {\n            const v = Number(headers[i + 1]);\n            if (!Number.isNaN(Number(v))) {\n                return v;\n            }\n            return undefined;\n        }\n    }\n    return undefined;\n}\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass FetchInstrumentation {\n    // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n    // unsubscribing.\n    channelSubs;\n    spanFromReq = new WeakMap();\n    tracer;\n    config;\n    meter;\n    instrumentationName = 'opentelemetry-instrumentation-node-18-fetch';\n    instrumentationVersion = '1.0.0';\n    instrumentationDescription = 'Instrumentation for Node 18 fetch via diagnostics_channel';\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        const channel = node_diagnostics_channel_1.default.channel(diagnosticChannel);\n        channel.subscribe(onMessage);\n        this.channelSubs.push({\n            name: diagnosticChannel,\n            channel,\n            onMessage,\n        });\n    }\n    constructor(config) {\n        // Force load fetch API (since it's lazy loaded in Node 18)\n        fetch('').catch(() => { });\n        this.channelSubs = [];\n        this.meter = api_1.metrics.getMeter(this.instrumentationName, this.instrumentationVersion);\n        this.tracer = api_1.trace.getTracer(this.instrumentationName, this.instrumentationVersion);\n        this.config = { ...config };\n    }\n    disable() {\n        this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));\n    }\n    enable() {\n        this.subscribeToChannel('undici:request:create', (args) => this.onRequest(args));\n        this.subscribeToChannel('undici:request:headers', (args) => this.onHeaders(args));\n        this.subscribeToChannel('undici:request:trailers', (args) => this.onDone(args));\n        this.subscribeToChannel('undici:request:error', (args) => this.onError(args));\n    }\n    setTracerProvider(tracerProvider) {\n        this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n    }\n    setMeterProvider(meterProvider) {\n        this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n    }\n    setConfig(config) {\n        this.config = { ...config };\n    }\n    getConfig() {\n        return this.config;\n    }\n    onRequest({ request }) {\n        // Don't instrument CONNECT - see comments at:\n        // https://github.com/elastic/apm-agent-nodejs/blob/c55b1d8c32b2574362fc24d81b8e173ce2f75257/lib/instrumentation/modules/undici.js#L24\n        if (request.method === 'CONNECT') {\n            return;\n        }\n        if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {\n            return;\n        }\n        const span = this.tracer.startSpan(`HTTP ${request.method}`, {\n            kind: api_1.SpanKind.CLIENT,\n            attributes: {\n                [semantic_conventions_1.SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),\n                [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: request.method,\n                [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: request.path,\n                'http.client': 'fetch',\n            },\n        });\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        if (this.config.onRequest) {\n            this.config.onRequest({ request, span, additionalHeaders: addedHeaders });\n        }\n        if (Array.isArray(request.headers)) {\n            request.headers.push(...Object.entries(addedHeaders).flat());\n        }\n        else {\n            request.headers += Object.entries(addedHeaders)\n                .map(([k, v]) => `${k}: ${v}\\r\\n`)\n                .join('');\n        }\n        this.spanFromReq.set(request, span);\n    }\n    onHeaders({ request, response }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            // We are currently *not* capturing response headers, even though the\n            // intake API does allow it, because none of the other `setHttpContext`\n            // uses currently do.\n            const cLen = contentLengthFromResponseHeaders(response.headers);\n            const attrs = {\n                [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode,\n            };\n            if (cLen) {\n                attrs[semantic_conventions_1.SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;\n            }\n            span.setAttributes(attrs);\n            span.setStatus({\n                code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.OK,\n                message: String(response.statusCode),\n            });\n        }\n    }\n    onDone({ request }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.end();\n            this.spanFromReq.delete(request);\n        }\n    }\n    onError({ request, error }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.recordException(error);\n            span.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: getMessage(error),\n            });\n            span.end();\n        }\n    }\n}\nexports.FetchInstrumentation = FetchInstrumentation;\nfunction getAbsoluteUrl(origin, path = '/') {\n    const url = `${origin}`;\n    if (origin.endsWith('/') && path.startsWith('/')) {\n        return `${url}${path.slice(1)}`;\n    }\n    if (!origin.endsWith('/') && !path.startsWith('/')) {\n        return `${url}/${path.slice(1)}`;\n    }\n    return `${url}${path}`;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGluc3RydW1lbnQpLy4vbm9kZV9tb2R1bGVzL29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9uLWZldGNoLW5vZGUvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxtQkFBTyxDQUFDLDBEQUEwQjtBQUNyRiwrQkFBK0IsbUJBQU8sQ0FBQywrSEFBcUM7QUFDNUUsY0FBYyxtQkFBTyxDQUFDLDZGQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnREFBZ0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUUsSUFBSSxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0Esa0JBQWtCLElBQUksRUFBRSxjQUFjO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsSUFBSSxHQUFHLGNBQWM7QUFDdkM7QUFDQSxjQUFjLElBQUksRUFBRSxLQUFLO0FBQ3pCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYXJlcHVsc2UvLi9ub2RlX21vZHVsZXMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb24tZmV0Y2gtbm9kZS9idWlsZC9pbmRleC5qcz80MjUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GZXRjaEluc3RydW1lbnRhdGlvbiA9IHZvaWQgMDtcbi8qXG4gKiBQb3J0aW9ucyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL2FwbS1hZ2VudC1ub2RlanNcbiAqIENvcHlyaWdodCBFbGFzdGljc2VhcmNoIEIuVi4gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB3aGVyZSBhcHBsaWNhYmxlLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAyLUNsYXVzZSBMaWNlbnNlOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpblxuICogY29tcGxpYW5jZSB3aXRoIHRoZSBCU0QgMi1DbGF1c2UgTGljZW5zZS5cbiAqXG4gKi9cbmNvbnN0IG5vZGVfZGlhZ25vc3RpY3NfY2hhbm5lbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOmRpYWdub3N0aWNzX2NoYW5uZWxcIikpO1xuY29uc3Qgc2VtYW50aWNfY29udmVudGlvbnNfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZW1hbnRpYy1jb252ZW50aW9uc1wiKTtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmZ1bmN0aW9uIGdldE1lc3NhZ2UoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBZ2dyZWdhdGVFcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IuZXJyb3JzLm1hcCgoZSkgPT4gZS5tZXNzYWdlKS5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbn1cbi8vIEdldCB0aGUgY29udGVudC1sZW5ndGggZnJvbSB1bmRpY2kgcmVzcG9uc2UgaGVhZGVycy5cbi8vIGBoZWFkZXJzYCBpcyBhbiBBcnJheSBvZiBidWZmZXJzOiBbaywgdiwgaywgdiwgLi4uXS5cbi8vIElmIHRoZSBoZWFkZXIgaXMgbm90IHByZXNlbnQsIG9yIGhhcyBhbiBpbnZhbGlkIHZhbHVlLCB0aGlzIHJldHVybnMgbnVsbC5cbmZ1bmN0aW9uIGNvbnRlbnRMZW5ndGhGcm9tUmVzcG9uc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICBjb25zdCBuYW1lID0gJ2NvbnRlbnQtbGVuZ3RoJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3QgayA9IGhlYWRlcnNbaV07XG4gICAgICAgIGlmIChrLmxlbmd0aCA9PT0gbmFtZS5sZW5ndGggJiYgay50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBOdW1iZXIoaGVhZGVyc1tpICsgMV0pO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyKHYpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLy8gQSBjb21iaW5hdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vZWxhc3RpYy9hcG0tYWdlbnQtbm9kZWpzIGFuZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dhZGdldC1pbmMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb25zL2Jsb2IvbWFpbi9wYWNrYWdlcy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbi11bmRpY2kvc3JjL2luZGV4LnRzXG5jbGFzcyBGZXRjaEluc3RydW1lbnRhdGlvbiB7XG4gICAgLy8gS2VlcCByZWYgdG8gYXZvaWQgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80MjE3MCBidWcgYW5kIGZvclxuICAgIC8vIHVuc3Vic2NyaWJpbmcuXG4gICAgY2hhbm5lbFN1YnM7XG4gICAgc3BhbkZyb21SZXEgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRyYWNlcjtcbiAgICBjb25maWc7XG4gICAgbWV0ZXI7XG4gICAgaW5zdHJ1bWVudGF0aW9uTmFtZSA9ICdvcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbi1ub2RlLTE4LWZldGNoJztcbiAgICBpbnN0cnVtZW50YXRpb25WZXJzaW9uID0gJzEuMC4wJztcbiAgICBpbnN0cnVtZW50YXRpb25EZXNjcmlwdGlvbiA9ICdJbnN0cnVtZW50YXRpb24gZm9yIE5vZGUgMTggZmV0Y2ggdmlhIGRpYWdub3N0aWNzX2NoYW5uZWwnO1xuICAgIHN1YnNjcmliZVRvQ2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCwgb25NZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWwgPSBub2RlX2RpYWdub3N0aWNzX2NoYW5uZWxfMS5kZWZhdWx0LmNoYW5uZWwoZGlhZ25vc3RpY0NoYW5uZWwpO1xuICAgICAgICBjaGFubmVsLnN1YnNjcmliZShvbk1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNoYW5uZWxTdWJzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogZGlhZ25vc3RpY0NoYW5uZWwsXG4gICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgICAgb25NZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8vIEZvcmNlIGxvYWQgZmV0Y2ggQVBJIChzaW5jZSBpdCdzIGxhenkgbG9hZGVkIGluIE5vZGUgMTgpXG4gICAgICAgIGZldGNoKCcnKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWxTdWJzID0gW107XG4gICAgICAgIHRoaXMubWV0ZXIgPSBhcGlfMS5tZXRyaWNzLmdldE1ldGVyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICAgICAgdGhpcy50cmFjZXIgPSBhcGlfMS50cmFjZS5nZXRUcmFjZXIodGhpcy5pbnN0cnVtZW50YXRpb25OYW1lLCB0aGlzLmluc3RydW1lbnRhdGlvblZlcnNpb24pO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHsgLi4uY29uZmlnIH07XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbFN1YnM/LmZvckVhY2goKHN1YikgPT4gc3ViLmNoYW5uZWwudW5zdWJzY3JpYmUoc3ViLm9uTWVzc2FnZSkpO1xuICAgIH1cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpjcmVhdGUnLCAoYXJncykgPT4gdGhpcy5vblJlcXVlc3QoYXJncykpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvQ2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycsIChhcmdzKSA9PiB0aGlzLm9uSGVhZGVycyhhcmdzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDp0cmFpbGVycycsIChhcmdzKSA9PiB0aGlzLm9uRG9uZShhcmdzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDplcnJvcicsIChhcmdzKSA9PiB0aGlzLm9uRXJyb3IoYXJncykpO1xuICAgIH1cbiAgICBzZXRUcmFjZXJQcm92aWRlcih0cmFjZXJQcm92aWRlcikge1xuICAgICAgICB0aGlzLnRyYWNlciA9IHRyYWNlclByb3ZpZGVyLmdldFRyYWNlcih0aGlzLmluc3RydW1lbnRhdGlvbk5hbWUsIHRoaXMuaW5zdHJ1bWVudGF0aW9uVmVyc2lvbik7XG4gICAgfVxuICAgIHNldE1ldGVyUHJvdmlkZXIobWV0ZXJQcm92aWRlcikge1xuICAgICAgICB0aGlzLm1ldGVyID0gbWV0ZXJQcm92aWRlci5nZXRNZXRlcih0aGlzLmluc3RydW1lbnRhdGlvbk5hbWUsIHRoaXMuaW5zdHJ1bWVudGF0aW9uVmVyc2lvbik7XG4gICAgfVxuICAgIHNldENvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7IC4uLmNvbmZpZyB9O1xuICAgIH1cbiAgICBnZXRDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZztcbiAgICB9XG4gICAgb25SZXF1ZXN0KHsgcmVxdWVzdCB9KSB7XG4gICAgICAgIC8vIERvbid0IGluc3RydW1lbnQgQ09OTkVDVCAtIHNlZSBjb21tZW50cyBhdDpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvYXBtLWFnZW50LW5vZGVqcy9ibG9iL2M1NWIxZDhjMzJiMjU3NDM2MmZjMjRkODFiOGUxNzNjZTJmNzUyNTcvbGliL2luc3RydW1lbnRhdGlvbi9tb2R1bGVzL3VuZGljaS5qcyNMMjRcbiAgICAgICAgaWYgKHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25maWcuaWdub3JlUmVxdWVzdEhvb2sgJiYgdGhpcy5jb25maWcuaWdub3JlUmVxdWVzdEhvb2socmVxdWVzdCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy50cmFjZXIuc3RhcnRTcGFuKGBIVFRQICR7cmVxdWVzdC5tZXRob2R9YCwge1xuICAgICAgICAgICAga2luZDogYXBpXzEuU3BhbktpbmQuQ0xJRU5ULFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX1VSTF06IGdldEFic29sdXRlVXJsKHJlcXVlc3Qub3JpZ2luLCByZXF1ZXN0LnBhdGgpLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX01FVEhPRF06IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICAgICAgICAgIFtzZW1hbnRpY19jb252ZW50aW9uc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX1RBUkdFVF06IHJlcXVlc3QucGF0aCxcbiAgICAgICAgICAgICAgICAnaHR0cC5jbGllbnQnOiAnZmV0Y2gnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDb250ZXh0ID0gYXBpXzEudHJhY2Uuc2V0U3BhbihhcGlfMS5jb250ZXh0LmFjdGl2ZSgpLCBzcGFuKTtcbiAgICAgICAgY29uc3QgYWRkZWRIZWFkZXJzID0ge307XG4gICAgICAgIGFwaV8xLnByb3BhZ2F0aW9uLmluamVjdChyZXF1ZXN0Q29udGV4dCwgYWRkZWRIZWFkZXJzKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9uUmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcub25SZXF1ZXN0KHsgcmVxdWVzdCwgc3BhbiwgYWRkaXRpb25hbEhlYWRlcnM6IGFkZGVkSGVhZGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXF1ZXN0LmhlYWRlcnMpKSB7XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMucHVzaCguLi5PYmplY3QuZW50cmllcyhhZGRlZEhlYWRlcnMpLmZsYXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMgKz0gT2JqZWN0LmVudHJpZXMoYWRkZWRIZWFkZXJzKVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYCR7a306ICR7dn1cXHJcXG5gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNwYW5Gcm9tUmVxLnNldChyZXF1ZXN0LCBzcGFuKTtcbiAgICB9XG4gICAgb25IZWFkZXJzKHsgcmVxdWVzdCwgcmVzcG9uc2UgfSkge1xuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5zcGFuRnJvbVJlcS5nZXQocmVxdWVzdCk7XG4gICAgICAgIGlmIChzcGFuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFdlIGFyZSBjdXJyZW50bHkgKm5vdCogY2FwdHVyaW5nIHJlc3BvbnNlIGhlYWRlcnMsIGV2ZW4gdGhvdWdoIHRoZVxuICAgICAgICAgICAgLy8gaW50YWtlIEFQSSBkb2VzIGFsbG93IGl0LCBiZWNhdXNlIG5vbmUgb2YgdGhlIG90aGVyIGBzZXRIdHRwQ29udGV4dGBcbiAgICAgICAgICAgIC8vIHVzZXMgY3VycmVudGx5IGRvLlxuICAgICAgICAgICAgY29uc3QgY0xlbiA9IGNvbnRlbnRMZW5ndGhGcm9tUmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfU1RBVFVTX0NPREVdOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjTGVuKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNbc2VtYW50aWNfY29udmVudGlvbnNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9SRVNQT05TRV9DT05URU5UX0xFTkdUSF0gPSBjTGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlID49IDQwMCA/IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SIDogYXBpXzEuU3BhblN0YXR1c0NvZGUuT0ssXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogU3RyaW5nKHJlc3BvbnNlLnN0YXR1c0NvZGUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Eb25lKHsgcmVxdWVzdCB9KSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW5Gcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5lbmQoKTtcbiAgICAgICAgICAgIHRoaXMuc3BhbkZyb21SZXEuZGVsZXRlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uRXJyb3IoeyByZXF1ZXN0LCBlcnJvciB9KSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW5Gcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3Bhbi5yZWNvcmRFeGNlcHRpb24oZXJyb3IpO1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IGFwaV8xLlNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGdldE1lc3NhZ2UoZXJyb3IpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5GZXRjaEluc3RydW1lbnRhdGlvbiA9IEZldGNoSW5zdHJ1bWVudGF0aW9uO1xuZnVuY3Rpb24gZ2V0QWJzb2x1dGVVcmwob3JpZ2luLCBwYXRoID0gJy8nKSB7XG4gICAgY29uc3QgdXJsID0gYCR7b3JpZ2lufWA7XG4gICAgaWYgKG9yaWdpbi5lbmRzV2l0aCgnLycpICYmIHBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBgJHt1cmx9JHtwYXRoLnNsaWNlKDEpfWA7XG4gICAgfVxuICAgIGlmICghb3JpZ2luLmVuZHNXaXRoKCcvJykgJiYgIXBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHJldHVybiBgJHt1cmx9LyR7cGF0aC5zbGljZSgxKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dXJsfSR7cGF0aH1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(instrument)/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchInstrumentation = void 0;\n/*\n * Portions from https://github.com/elastic/apm-agent-nodejs\n * Copyright Elasticsearch B.V. and other contributors where applicable.\n * Licensed under the BSD 2-Clause License; you may not use this file except in\n * compliance with the BSD 2-Clause License.\n *\n */\nconst node_diagnostics_channel_1 = __importDefault(__webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\"));\nconst semantic_conventions_1 = __webpack_require__(/*! @opentelemetry/semantic-conventions */ \"(rsc)/./node_modules/@opentelemetry/semantic-conventions/build/esm/index.js\");\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nfunction getMessage(error) {\n    if (error instanceof AggregateError) {\n        return error.errors.map((e) => e.message).join(', ');\n    }\n    return error.message;\n}\n// Get the content-length from undici response headers.\n// `headers` is an Array of buffers: [k, v, k, v, ...].\n// If the header is not present, or has an invalid value, this returns null.\nfunction contentLengthFromResponseHeaders(headers) {\n    const name = 'content-length';\n    for (let i = 0; i < headers.length; i += 2) {\n        const k = headers[i];\n        if (k.length === name.length && k.toString().toLowerCase() === name) {\n            const v = Number(headers[i + 1]);\n            if (!Number.isNaN(Number(v))) {\n                return v;\n            }\n            return undefined;\n        }\n    }\n    return undefined;\n}\n// A combination of https://github.com/elastic/apm-agent-nodejs and\n// https://github.com/gadget-inc/opentelemetry-instrumentations/blob/main/packages/opentelemetry-instrumentation-undici/src/index.ts\nclass FetchInstrumentation {\n    // Keep ref to avoid https://github.com/nodejs/node/issues/42170 bug and for\n    // unsubscribing.\n    channelSubs;\n    spanFromReq = new WeakMap();\n    tracer;\n    config;\n    meter;\n    instrumentationName = 'opentelemetry-instrumentation-node-18-fetch';\n    instrumentationVersion = '1.0.0';\n    instrumentationDescription = 'Instrumentation for Node 18 fetch via diagnostics_channel';\n    subscribeToChannel(diagnosticChannel, onMessage) {\n        const channel = node_diagnostics_channel_1.default.channel(diagnosticChannel);\n        channel.subscribe(onMessage);\n        this.channelSubs.push({\n            name: diagnosticChannel,\n            channel,\n            onMessage,\n        });\n    }\n    constructor(config) {\n        // Force load fetch API (since it's lazy loaded in Node 18)\n        fetch('').catch(() => { });\n        this.channelSubs = [];\n        this.meter = api_1.metrics.getMeter(this.instrumentationName, this.instrumentationVersion);\n        this.tracer = api_1.trace.getTracer(this.instrumentationName, this.instrumentationVersion);\n        this.config = { ...config };\n    }\n    disable() {\n        this.channelSubs?.forEach((sub) => sub.channel.unsubscribe(sub.onMessage));\n    }\n    enable() {\n        this.subscribeToChannel('undici:request:create', (args) => this.onRequest(args));\n        this.subscribeToChannel('undici:request:headers', (args) => this.onHeaders(args));\n        this.subscribeToChannel('undici:request:trailers', (args) => this.onDone(args));\n        this.subscribeToChannel('undici:request:error', (args) => this.onError(args));\n    }\n    setTracerProvider(tracerProvider) {\n        this.tracer = tracerProvider.getTracer(this.instrumentationName, this.instrumentationVersion);\n    }\n    setMeterProvider(meterProvider) {\n        this.meter = meterProvider.getMeter(this.instrumentationName, this.instrumentationVersion);\n    }\n    setConfig(config) {\n        this.config = { ...config };\n    }\n    getConfig() {\n        return this.config;\n    }\n    onRequest({ request }) {\n        // Don't instrument CONNECT - see comments at:\n        // https://github.com/elastic/apm-agent-nodejs/blob/c55b1d8c32b2574362fc24d81b8e173ce2f75257/lib/instrumentation/modules/undici.js#L24\n        if (request.method === 'CONNECT') {\n            return;\n        }\n        if (this.config.ignoreRequestHook && this.config.ignoreRequestHook(request) === true) {\n            return;\n        }\n        const span = this.tracer.startSpan(`HTTP ${request.method}`, {\n            kind: api_1.SpanKind.CLIENT,\n            attributes: {\n                [semantic_conventions_1.SemanticAttributes.HTTP_URL]: getAbsoluteUrl(request.origin, request.path),\n                [semantic_conventions_1.SemanticAttributes.HTTP_METHOD]: request.method,\n                [semantic_conventions_1.SemanticAttributes.HTTP_TARGET]: request.path,\n                'http.client': 'fetch',\n            },\n        });\n        const requestContext = api_1.trace.setSpan(api_1.context.active(), span);\n        const addedHeaders = {};\n        api_1.propagation.inject(requestContext, addedHeaders);\n        if (this.config.onRequest) {\n            this.config.onRequest({ request, span, additionalHeaders: addedHeaders });\n        }\n        if (Array.isArray(request.headers)) {\n            request.headers.push(...Object.entries(addedHeaders).flat());\n        }\n        else {\n            request.headers += Object.entries(addedHeaders)\n                .map(([k, v]) => `${k}: ${v}\\r\\n`)\n                .join('');\n        }\n        this.spanFromReq.set(request, span);\n    }\n    onHeaders({ request, response }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            // We are currently *not* capturing response headers, even though the\n            // intake API does allow it, because none of the other `setHttpContext`\n            // uses currently do.\n            const cLen = contentLengthFromResponseHeaders(response.headers);\n            const attrs = {\n                [semantic_conventions_1.SemanticAttributes.HTTP_STATUS_CODE]: response.statusCode,\n            };\n            if (cLen) {\n                attrs[semantic_conventions_1.SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH] = cLen;\n            }\n            span.setAttributes(attrs);\n            span.setStatus({\n                code: response.statusCode >= 400 ? api_1.SpanStatusCode.ERROR : api_1.SpanStatusCode.OK,\n                message: String(response.statusCode),\n            });\n        }\n    }\n    onDone({ request }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.end();\n            this.spanFromReq.delete(request);\n        }\n    }\n    onError({ request, error }) {\n        const span = this.spanFromReq.get(request);\n        if (span !== undefined) {\n            span.recordException(error);\n            span.setStatus({\n                code: api_1.SpanStatusCode.ERROR,\n                message: getMessage(error),\n            });\n            span.end();\n        }\n    }\n}\nexports.FetchInstrumentation = FetchInstrumentation;\nfunction getAbsoluteUrl(origin, path = '/') {\n    const url = `${origin}`;\n    if (origin.endsWith('/') && path.startsWith('/')) {\n        return `${url}${path.slice(1)}`;\n    }\n    if (!origin.endsWith('/') && !path.startsWith('/')) {\n        return `${url}/${path.slice(1)}`;\n    }\n    return `${url}${path}`;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvb3BlbnRlbGVtZXRyeS1pbnN0cnVtZW50YXRpb24tZmV0Y2gtbm9kZS9idWlsZC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG1CQUFPLENBQUMsMERBQTBCO0FBQ3JGLCtCQUErQixtQkFBTyxDQUFDLHdIQUFxQztBQUM1RSxjQUFjLG1CQUFPLENBQUMsc0ZBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdEQUFnRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsRUFBRSxJQUFJLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQSxrQkFBa0IsSUFBSSxFQUFFLGNBQWM7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixJQUFJLEdBQUcsY0FBYztBQUN2QztBQUNBLGNBQWMsSUFBSSxFQUFFLEtBQUs7QUFDekI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NhcmVwdWxzZS8uL25vZGVfbW9kdWxlcy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbi1mZXRjaC1ub2RlL2J1aWxkL2luZGV4LmpzPzUyM2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZldGNoSW5zdHJ1bWVudGF0aW9uID0gdm9pZCAwO1xuLypcbiAqIFBvcnRpb25zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VsYXN0aWMvYXBtLWFnZW50LW5vZGVqc1xuICogQ29weXJpZ2h0IEVsYXN0aWNzZWFyY2ggQi5WLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHdoZXJlIGFwcGxpY2FibGUuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQlNEIDItQ2xhdXNlIExpY2Vuc2U7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluXG4gKiBjb21wbGlhbmNlIHdpdGggdGhlIEJTRCAyLUNsYXVzZSBMaWNlbnNlLlxuICpcbiAqL1xuY29uc3Qgbm9kZV9kaWFnbm9zdGljc19jaGFubmVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIm5vZGU6ZGlhZ25vc3RpY3NfY2hhbm5lbFwiKSk7XG5jb25zdCBzZW1hbnRpY19jb252ZW50aW9uc18xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L3NlbWFudGljLWNvbnZlbnRpb25zXCIpO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuZnVuY3Rpb24gZ2V0TWVzc2FnZShlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEFnZ3JlZ2F0ZUVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5lcnJvcnMubWFwKChlKSA9PiBlLm1lc3NhZ2UpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xufVxuLy8gR2V0IHRoZSBjb250ZW50LWxlbmd0aCBmcm9tIHVuZGljaSByZXNwb25zZSBoZWFkZXJzLlxuLy8gYGhlYWRlcnNgIGlzIGFuIEFycmF5IG9mIGJ1ZmZlcnM6IFtrLCB2LCBrLCB2LCAuLi5dLlxuLy8gSWYgdGhlIGhlYWRlciBpcyBub3QgcHJlc2VudCwgb3IgaGFzIGFuIGludmFsaWQgdmFsdWUsIHRoaXMgcmV0dXJucyBudWxsLlxuZnVuY3Rpb24gY29udGVudExlbmd0aEZyb21SZXNwb25zZUhlYWRlcnMoaGVhZGVycykge1xuICAgIGNvbnN0IG5hbWUgPSAnY29udGVudC1sZW5ndGgnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBrID0gaGVhZGVyc1tpXTtcbiAgICAgICAgaWYgKGsubGVuZ3RoID09PSBuYW1lLmxlbmd0aCAmJiBrLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IE51bWJlcihoZWFkZXJzW2kgKyAxXSk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihOdW1iZXIodikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBBIGNvbWJpbmF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGFzdGljL2FwbS1hZ2VudC1ub2RlanMgYW5kXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZ2FkZ2V0LWluYy9vcGVudGVsZW1ldHJ5LWluc3RydW1lbnRhdGlvbnMvYmxvYi9tYWluL3BhY2thZ2VzL29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9uLXVuZGljaS9zcmMvaW5kZXgudHNcbmNsYXNzIEZldGNoSW5zdHJ1bWVudGF0aW9uIHtcbiAgICAvLyBLZWVwIHJlZiB0byBhdm9pZCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQyMTcwIGJ1ZyBhbmQgZm9yXG4gICAgLy8gdW5zdWJzY3JpYmluZy5cbiAgICBjaGFubmVsU3VicztcbiAgICBzcGFuRnJvbVJlcSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdHJhY2VyO1xuICAgIGNvbmZpZztcbiAgICBtZXRlcjtcbiAgICBpbnN0cnVtZW50YXRpb25OYW1lID0gJ29wZW50ZWxlbWV0cnktaW5zdHJ1bWVudGF0aW9uLW5vZGUtMTgtZmV0Y2gnO1xuICAgIGluc3RydW1lbnRhdGlvblZlcnNpb24gPSAnMS4wLjAnO1xuICAgIGluc3RydW1lbnRhdGlvbkRlc2NyaXB0aW9uID0gJ0luc3RydW1lbnRhdGlvbiBmb3IgTm9kZSAxOCBmZXRjaCB2aWEgZGlhZ25vc3RpY3NfY2hhbm5lbCc7XG4gICAgc3Vic2NyaWJlVG9DaGFubmVsKGRpYWdub3N0aWNDaGFubmVsLCBvbk1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IG5vZGVfZGlhZ25vc3RpY3NfY2hhbm5lbF8xLmRlZmF1bHQuY2hhbm5lbChkaWFnbm9zdGljQ2hhbm5lbCk7XG4gICAgICAgIGNoYW5uZWwuc3Vic2NyaWJlKG9uTWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbFN1YnMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBkaWFnbm9zdGljQ2hhbm5lbCxcbiAgICAgICAgICAgIGNoYW5uZWwsXG4gICAgICAgICAgICBvbk1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLy8gRm9yY2UgbG9hZCBmZXRjaCBBUEkgKHNpbmNlIGl0J3MgbGF6eSBsb2FkZWQgaW4gTm9kZSAxOClcbiAgICAgICAgZmV0Y2goJycpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIHRoaXMuY2hhbm5lbFN1YnMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXRlciA9IGFwaV8xLm1ldHJpY3MuZ2V0TWV0ZXIodGhpcy5pbnN0cnVtZW50YXRpb25OYW1lLCB0aGlzLmluc3RydW1lbnRhdGlvblZlcnNpb24pO1xuICAgICAgICB0aGlzLnRyYWNlciA9IGFwaV8xLnRyYWNlLmdldFRyYWNlcih0aGlzLmluc3RydW1lbnRhdGlvbk5hbWUsIHRoaXMuaW5zdHJ1bWVudGF0aW9uVmVyc2lvbik7XG4gICAgICAgIHRoaXMuY29uZmlnID0geyAuLi5jb25maWcgfTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsU3Vicz8uZm9yRWFjaCgoc3ViKSA9PiBzdWIuY2hhbm5lbC51bnN1YnNjcmliZShzdWIub25NZXNzYWdlKSk7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmNyZWF0ZScsIChhcmdzKSA9PiB0aGlzLm9uUmVxdWVzdChhcmdzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9DaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpoZWFkZXJzJywgKGFyZ3MpID0+IHRoaXMub25IZWFkZXJzKGFyZ3MpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJywgKGFyZ3MpID0+IHRoaXMub25Eb25lKGFyZ3MpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0NoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJywgKGFyZ3MpID0+IHRoaXMub25FcnJvcihhcmdzKSk7XG4gICAgfVxuICAgIHNldFRyYWNlclByb3ZpZGVyKHRyYWNlclByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMudHJhY2VyID0gdHJhY2VyUHJvdmlkZXIuZ2V0VHJhY2VyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICB9XG4gICAgc2V0TWV0ZXJQcm92aWRlcihtZXRlclByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMubWV0ZXIgPSBtZXRlclByb3ZpZGVyLmdldE1ldGVyKHRoaXMuaW5zdHJ1bWVudGF0aW9uTmFtZSwgdGhpcy5pbnN0cnVtZW50YXRpb25WZXJzaW9uKTtcbiAgICB9XG4gICAgc2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHsgLi4uY29uZmlnIH07XG4gICAgfVxuICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xuICAgIH1cbiAgICBvblJlcXVlc3QoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgLy8gRG9uJ3QgaW5zdHJ1bWVudCBDT05ORUNUIC0gc2VlIGNvbW1lbnRzIGF0OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZWxhc3RpYy9hcG0tYWdlbnQtbm9kZWpzL2Jsb2IvYzU1YjFkOGMzMmIyNTc0MzYyZmMyNGQ4MWI4ZTE3M2NlMmY3NTI1Ny9saWIvaW5zdHJ1bWVudGF0aW9uL21vZHVsZXMvdW5kaWNpLmpzI0wyNFxuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5pZ25vcmVSZXF1ZXN0SG9vayAmJiB0aGlzLmNvbmZpZy5pZ25vcmVSZXF1ZXN0SG9vayhyZXF1ZXN0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnRyYWNlci5zdGFydFNwYW4oYEhUVFAgJHtyZXF1ZXN0Lm1ldGhvZH1gLCB7XG4gICAgICAgICAgICBraW5kOiBhcGlfMS5TcGFuS2luZC5DTElFTlQsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfVVJMXTogZ2V0QWJzb2x1dGVVcmwocmVxdWVzdC5vcmlnaW4sIHJlcXVlc3QucGF0aCksXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfTUVUSE9EXTogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICAgICAgW3NlbWFudGljX2NvbnZlbnRpb25zXzEuU2VtYW50aWNBdHRyaWJ1dGVzLkhUVFBfVEFSR0VUXTogcmVxdWVzdC5wYXRoLFxuICAgICAgICAgICAgICAgICdodHRwLmNsaWVudCc6ICdmZXRjaCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdENvbnRleHQgPSBhcGlfMS50cmFjZS5zZXRTcGFuKGFwaV8xLmNvbnRleHQuYWN0aXZlKCksIHNwYW4pO1xuICAgICAgICBjb25zdCBhZGRlZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgYXBpXzEucHJvcGFnYXRpb24uaW5qZWN0KHJlcXVlc3RDb250ZXh0LCBhZGRlZEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcub25SZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZy5vblJlcXVlc3QoeyByZXF1ZXN0LCBzcGFuLCBhZGRpdGlvbmFsSGVhZGVyczogYWRkZWRIZWFkZXJzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlcXVlc3QuaGVhZGVycykpIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5wdXNoKC4uLk9iamVjdC5lbnRyaWVzKGFkZGVkSGVhZGVycykuZmxhdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3QuaGVhZGVycyArPSBPYmplY3QuZW50cmllcyhhZGRlZEhlYWRlcnMpXG4gICAgICAgICAgICAgICAgLm1hcCgoW2ssIHZdKSA9PiBgJHtrfTogJHt2fVxcclxcbmApXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3BhbkZyb21SZXEuc2V0KHJlcXVlc3QsIHNwYW4pO1xuICAgIH1cbiAgICBvbkhlYWRlcnMoeyByZXF1ZXN0LCByZXNwb25zZSB9KSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLnNwYW5Gcm9tUmVxLmdldChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHNwYW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIGN1cnJlbnRseSAqbm90KiBjYXB0dXJpbmcgcmVzcG9uc2UgaGVhZGVycywgZXZlbiB0aG91Z2ggdGhlXG4gICAgICAgICAgICAvLyBpbnRha2UgQVBJIGRvZXMgYWxsb3cgaXQsIGJlY2F1c2Ugbm9uZSBvZiB0aGUgb3RoZXIgYHNldEh0dHBDb250ZXh0YFxuICAgICAgICAgICAgLy8gdXNlcyBjdXJyZW50bHkgZG8uXG4gICAgICAgICAgICBjb25zdCBjTGVuID0gY29udGVudExlbmd0aEZyb21SZXNwb25zZUhlYWRlcnMocmVzcG9uc2UuaGVhZGVycyk7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IHtcbiAgICAgICAgICAgICAgICBbc2VtYW50aWNfY29udmVudGlvbnNfMS5TZW1hbnRpY0F0dHJpYnV0ZXMuSFRUUF9TVEFUVVNfQ09ERV06IHJlc3BvbnNlLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGNMZW4pIHtcbiAgICAgICAgICAgICAgICBhdHRyc1tzZW1hbnRpY19jb252ZW50aW9uc18xLlNlbWFudGljQXR0cmlidXRlcy5IVFRQX1JFU1BPTlNFX0NPTlRFTlRfTEVOR1RIXSA9IGNMZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoYXR0cnMpO1xuICAgICAgICAgICAgc3Bhbi5zZXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwID8gYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IgOiBhcGlfMS5TcGFuU3RhdHVzQ29kZS5PSyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTdHJpbmcocmVzcG9uc2Uuc3RhdHVzQ29kZSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRvbmUoeyByZXF1ZXN0IH0pIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbkZyb21SZXEuZ2V0KHJlcXVlc3QpO1xuICAgICAgICBpZiAoc3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgdGhpcy5zcGFuRnJvbVJlcS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25FcnJvcih7IHJlcXVlc3QsIGVycm9yIH0pIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuc3BhbkZyb21SZXEuZ2V0KHJlcXVlc3QpO1xuICAgICAgICBpZiAoc3BhbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbihlcnJvcik7XG4gICAgICAgICAgICBzcGFuLnNldFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogYXBpXzEuU3BhblN0YXR1c0NvZGUuRVJST1IsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2V0TWVzc2FnZShlcnJvciksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkZldGNoSW5zdHJ1bWVudGF0aW9uID0gRmV0Y2hJbnN0cnVtZW50YXRpb247XG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVVybChvcmlnaW4sIHBhdGggPSAnLycpIHtcbiAgICBjb25zdCB1cmwgPSBgJHtvcmlnaW59YDtcbiAgICBpZiAob3JpZ2luLmVuZHNXaXRoKCcvJykgJiYgcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3VybH0ke3BhdGguc2xpY2UoMSl9YDtcbiAgICB9XG4gICAgaWYgKCFvcmlnaW4uZW5kc1dpdGgoJy8nKSAmJiAhcGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgcmV0dXJuIGAke3VybH0vJHtwYXRoLnNsaWNlKDEpfWA7XG4gICAgfVxuICAgIHJldHVybiBgJHt1cmx9JHtwYXRofWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/opentelemetry-instrumentation-fetch-node/build/index.js\n");

/***/ })

};
;